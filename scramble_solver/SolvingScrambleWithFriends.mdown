# DAWG or DAWG not.  There is no Trie.

## Solving Scramble with Friends - Recursion, Stacks, and Tries

Apologies to Yoda, and to you for having to read such a bad pun.  This post aims to illustrate how to solve Scramble With Friends/Boggle and the techniques and data structures necessary.  It will touch on the naiive solution, as well as more efficient data structures such as the trie and DAWG.

# Problem statement
Given an N x N board, (4x4 in case of Scramble with Friends), find the set of all words and the path through the board that makes the words that can be formed from moving in any of 8 adjacent tiles, using each tile at most once.

![Scramble Screenshot][]

# The Naive / Brute Force Solution

Just for fun, let's imagine the most mind-numbingly stupid way possible of solving it - by enumerating each possible permutation of letters and filtering out the non-word combinations.  What is the approximate running time of that algorithm?

Well, you can imagine a decision tree of possibilities.  At the root would be a tile, under it would be up to 4 possibilities, under it would be up to 3 possibilities, and so on and so forth up to a maximum depth of 16.  This represents all the possible character strings which can be made starting from a given tile.  There would be 16 such trees, one for each starting position.

As a very approximate upper bound, this tree would have size 






I will first illustrate a brute force, recursive solution in Python.  As you probably remember, recursion is simply when a method calls itself.  In order to avoid an infinite loop (and eventual stack overflow), there must be some sort of stopping criteria.  Before moving on to the code, here's the basic strategy:

	Start search at a given point on the board
	Examine square
		If the entire word built up so far is a word, add it to list
		If the word built up so far + the new letter starts at least one word in the dictionary
			Recursively search all squares around this one, ensuring that we neither go off the board nor reuse a square
		
## Data structures

The data structure you choose has a huge effect on the runtime of the algorithm.  
		
		
## Optimization
This algorithm works but it is extremely inefficient.  Why?  For each square we examine, we need to examine the entire dictionary (all M words) and do a 'startswith' check on all of them

O(n)

Wouldn't it make more sense to eliminate a large number of words?

binary search - O(log n) - but we're not searching for a specific entry, but just that one *starts* with a specific substring


## Tries


"Looking up a key of length m takes worst case O(m) time. A BST performs O(log(n)) comparisons of keys, where n is the number of elements in the tree, because lookups depend on the depth of the tree, which is logarithmic in the number of keys if the tree is balanced. Hence in the worst case, a BST takes O(m log n) time. Moreover, in the worst case log(n) will approach m. Also, the simple operations tries use during lookup, such as array indexing using a character, are fast on real machines"
-- [Trie wikipedia][]


# Trie results


# Can we do better?
Tries are a huge improvement over a naive list or dict data structure, but they are not optimal for space purposes.


# DAWG
[Directed acyclic word graph][]


"The primary difference between DAWG and trie is the elimination of suffix redundancy in storing strings. The trie eliminates prefix redundancy since all common prefixes are shared between strings, such as between doctors and doctorate the doctor prefix is shared. In a DAWG common suffixes are also shared, such as between desertion and destruction both the prefix des- and suffix -tion are shared. For dictionary sets of common English words, this translates into major memory usage reduction.
Because the terminal nodes of a DAWG can be reached by multiple paths, a DAWG cannot directly store auxiliary information relating to each path, e.g. a word's frequency in the English language. However, if at each node we store a count of the number of unique paths through the structure from that point, we can use it to retrieve the index of a word, or a word given its index.[1] The auxiliary information can then be stored in an array" -- [Directed acyclic word graph][]



# Conclusion
We have seen how using the correct data structure (trie) makes an enormous difference when it comes to runtime performance.  

We have also seen how recursion makes it very succint to express an algorithm that otherwise would be very complicated

We have also seen how to replace a recursive implementation with an explicit stack based, iterative approach.



[Trie wikipedia]:http://en.wikipedia.org/wiki/Trie
[Directed acyclic word graph]:http://en.wikipedia.org/wiki/Directed_acyclic_word_graph
[fast scrabble solver]:http://www.cs.cmu.edu/afs/cs/academic/class/15451-s06/www/lectures/scrabble.pdf
[Compressiong dictionaries with a DAWG: dawg in python]:http://stevehanov.ca/blog/index.php?id=115
[wordutils dawg]:http://pypi.python.org/pypi/WordUtils/0.8.0
[extremely space efficient dawg]:http://www.wutka.com/dawg.html
[Scramble screenshot]: