If you do any sort of desktop Java programming with JTables and/or JLists, you really owe it to yourself to try Glazed Lists.  It's an actively developed open source project that makes all sorts of complicated list transformations easy.

The library simplifies three common tasks which alone make it worth downloading.

1) Providing a simplified API for representing objects within a JTable

When using the plain JTable implementation, the most painful part is defining the TableModel implementation, which informs the JTable as to what contents to display within it.  (The JTable is the view, the TableModel serves as the Model, in a standard MVC paradigm). 

Fortunately the AbstractTableModel does most of the work for you, requiring you only to implement the following methods:

<div>
[sourcecode language="java"]
public int getRowCount();
public int getColumnCount();
public Object getValueAt(int row, int column);
[/sourcecode]
</div>

Here's a simple domain model object we might want to visualize in a table:

[sourcecode language="java"]
public class Person {
	int age;
	String name;
	
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	
	public int getAge() { return age; }
	
	public String getName() { return name; }
}
[/sourcecode]

The logical way of doing that would be two have two columns, one for the age, one for the name.  Let's make a table model for this case:

<div>
[sourcecode language="java"]
public class PersonTableModel extends AbstractTableModel {
	    String[] columns = {"Name","Age"};
		

}
[/sourcecode]
</div>

  

http://download.oracle.com/javase/tutorial/uiswing/components/table.html#data



GlazedLists simplifies your life by treating the table not as an arbitrary two dimensional grid, but instead as a collection of rows.  All you have to do is define how a row is laid out, and glazedlists takes care of the rest. 

http://download.oracle.com/javase/tutorial/uiswing/components/table.html#data


What glazedlists does is allow you to treat the contents of your table at a higher level of abstraction.  Rather than considering the table as an arbitrary two-dimensional array of cells, each of which is completely disconnected from each other, GlazedLists is designed for the case where you are representing a list of objects, where each column corresponds to some attribute of that object.  For all the uses I've ever had for a JTable, this has been precisely my purpose, so this allows me a much easier time.

The interface you need to use in order to define how the table looks and which aspects of your model objects are exposed is called TableFormat. 

The interface looks like as follows:
 int
getColumnCount()
          The number of columns to display.
 String
getColumnName(int column)
          Gets the title of the specified column.
 Object
getColumnValue(E baseObject, int column)
          Gets the value of the specified field for the specified object.




OK great, this isn't hard to implement at all. 

Here is a TableFormat which allows Person objects to be easily visible in a JTable:

[sourcecode language="java"]
public class PersonTableFormat implements TableFormat<Person> {
	
	String[] columnNames = {"Name", "Age"};
	private static final int NAME_INDEX = 0;
	private static final int AGE_INDEX = 1;
   
	public int getColumnCount() { return columnNames.length; }

    public String getColumnName(int column) { return columnNames[i]; }

    public Object getColumnValue(Person baseObject, int column) {
		switch (column) {
			case NAME_INDEX:
				return baseObject.getName();
			case AGE_INDEX:
				return baseObject.getAge();
			default:
				throw new IllegalArgumentException("Expected column 0 or 1, got " + column);
		}
	}
}
[/sourcecode]

While this isn't too hard to write, it's still a lot of boilerplate.  GlazedLists makes it even easier than this.  The above can be replaced with one line of code:

[sourcecode language="java"]
TableFormat<Person> = GlazedLists.tableFormat(Person.class, new String[] {"name","age"}, new String[]{"Name", "Age"});
[/sourcecode]

What's this doing?  And how can it do all that I had previously in one line of code?  Well, it takes advantage of and requires the use of JavaBeans naming convention.  The class uses reflection to find the methods mapping to properties named "name" and "age".  In this case, it looks for two methods, getName() and getAge(), both of which it finds.  (If I didn't name my methods appropriately, I would get a runtime exception).  The second array defines the strings that should be used to identify the corresponding entry in the properties array.  In other words, element 0 in the names column is used to identify the property name at index 0. 

The one problem with this way of defining the table format is that you are required to maintain two parallel arrays; if you change the order of the properties array, you need to be sure that you change the corresponding entry in the column names array.  One way to avoid this would be to generate the names array dynamically from the properties array; for instance in the simple case presented above, you could just capitalize the first letter in each property.

[sourcecode language="java"]
String[] propertyNames = {"name","age"};
String[] columnNames = titleCase(propertyNames);

public String[] titleCase(String[] camelCase) {
    String[] titleCase = new String[camelCase.length];
    for (int i = 0; i < camelCase.length; i++) {
	    titleCase[i] = toTitleCase(camelCase[i]);
	}
	return titleCase;
}

String toTitleCase(String camelCase) {
    String spaceSeparated = camelCase.replaceAll("([a-z])([A-Z])", "$1 $2");
    return Character.toUpperCase(spaceSeparated.charAt(0)) + spaceSeparated.substring(1);
}
[/sourcecode]

2) Providing a simplified means of filtering a table or list

Here's where GlazedLists really begins to show off its power.  Once you have an EventList of some sort, it is easy to create a new "view" of that same list, filtering out entries you don't want to see.  You do this by wrapping the list in a FilterList, and then assigning some sort of filter criterion.  For instance,

EventList<Person> people = GlazedLists.


3) Providing a simplified means of sorting a table or list









