2011-02-07

I've written previously about [EventBus], a great open source Java library for [pub-sub (publish subscribe)][2].  It's a truly excellent way to write loosely coupled systems, and much preferable to having to make your domain models extends [Observable][3] and your listeners implement [Observer][4].  I'm writing today to describe some difficulties in incorporating EventBus into unit tests, and how to overcome that problem.

## Test setup
I was attempting to test that certain messages were being published by a domain model object when they were supposed to.  In order to test this, I wrote a simple class that did nothing more than listen to the topics I knew that my model object was supposed to publish to, and then increment a counter when these methods were called.  It looked something like this:

<div>
[sourcecode language="java"]
class EventBusListener {
	private int numTimesTopicOneCalled = 0;
	private int numTimesTopicTwoCalled = 0;
	
	public EventBusListener() {
		AnnotationProcessor.process(this);
	}
	
	@EventTopicSubscriber(topic="topic_one")
	public void topicOneCalled(String topic, Object arg) {
		this.numTimesTopicOneCalled++;
	}

	@EventTopicSubscriber(topic="topic_two")
	public void topicTwoCalled(String topic, Object arg) {
		this.numTimesTopicTwoCalled++;
	}
	
	public int getNumTimesTopicOneCalled() {
		return this.numTimesTopicOneCalled;
	}
	
	public int getNumTimesTopicOneCalled() {
		return this.numTimesTopicTwoCalled;
	}
}
[/sourcecode]
</div>

The basic test routine looked something like this:

<div>
[sourcecode language="java"]
@Test
public void testTopicsFired() {
	
	
	// Uses EventBus internally
	DomainObject obj = new DomainObject();
	
	int count = 10;
	EventBusListener listener = new EventBusListener();
	for (int i = 0; i < count; i++) {
		obj.doSomethingThatShouldFireEventBusPublishing();
	}
	
	assertEquals(count, listener.getNumTimesTopicOneCalled());
	assertEquals(count, listener.getNumTimesTopicTwoCalled());
}
[/sourcecode]
</div>

This code kept failing, but in nondeterministic ways - sometimes the listener would report having its topic one called 4 times instead of 10, sometimes 7, but never the same issue twice.  Stepping through the code in debug mode I saw that the calls to `EventBus.publish` were in place, and sometimes they worked. Nondeterminism like this made me think of a threading issue, so I began to investigate.

## Problem
After reading through the [EventBus javadoc][5], I came upon the root of the problem:

> The EventBus is really just a convenience class that provides a static wrapper around a global EventService instance. This class exists solely for simplicity. Calling EventBus.subscribeXXX/publishXXX is equivalent to EventServiceLocator.getEventBusService().subscribeXXX/publishXXX, it is just shorter to type. See EventServiceLocator for details on how to customize the global EventService in place of the default SwingEventService.

And from the [SwingEventService javadoc][6] (emphasis mine):

> This class is Swing thread-safe. **All publish() calls NOT on the Swing EventDispatchThread thread are queued onto the EDT**. If the calling thread is the EDT, then this is a simple pass-through (i.e the subscribers are notified on the same stack frame, just like they would be had they added themselves via Swing addXXListener methods).

Here's the crux of the issue: the EventBus.publish calls are *not* occurring on the EventDispatchThread, since the Unit testing environment is headless and this domain object is similarly not graphical.  Thus these calls are being queued up using `SwingUtilities.invokeLater`, and they have no executed by the time the unit test has completed.  This leads to the non-deterministic behavior, as a certain number of the queued up messages are able to be processed before the end of execution of the unit test, but not all of them.


## Solutions

### Sleep Hack
One solution, albeit a terrible one, would be to put a hack in:

<div>
[sourcecode language="java"]
@Test
public void testTopicsFired() {
	// same as before

	// Let the messages get dequeued
	try {
		Thread.sleep(3000);
	}
	catch (InterruptedException e) {}
	
	assertEquals(count, listener.getNumTimesTopicOneCalled());
	assertEquals(count, listener.getNumTimesTopicTwoCalled());
}
[/sourcecode]
</div>

This is an awful solution because it involves an absolute hack.  Furthermore, it makes that unit test always take at least 3 seconds, which is going to slow the whole test suite down.

### ThreadSafeEventService



## Conclusion




[1]:http://developmentality.wordpress.com/2010/05/11/eventbus-introduction-and-troubleshooting-for-annotation-problems/
[2]:http://en.wikipedia.org/wiki/Publish/subscribe
[3]:http://download.oracle.com/javase/1.4.2/docs/api/java/util/Observable.html
[4]:http://download.oracle.com/javase/1.4.2/docs/api/java/util/Observer.html
[5]:http://www.jarvana.com/jarvana/view/org/bushe/eventbus/1.3/eventbus-1.3-javadoc.jar!/org/bushe/swing/event/EventBus.html
[6]:http://eventbus.org/api/org/bushe/swing/event/SwingEventService.html